<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ndarray: Main</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Main</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1ArrayTraits.html">ndarray::ArrayTraits&lt; T, N, C &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimension-specialized traits shared by <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> and <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a>.  <a href="structndarray_1_1ArrayTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1ExpressionTraits.html">ndarray::ExpressionTraits&lt; Expression_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traits for expressions.  <a href="structndarray_1_1ExpressionTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1NumericTraits.html">ndarray::NumericTraits&lt; T, U, is_complex, is_arithmetic &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Numeric type traits.  <a href="structndarray_1_1NumericTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1Promote.html">ndarray::Promote&lt; T1, T2, winner, is_complex &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction to compute numeric promotions.  <a href="structndarray_1_1Promote.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1ApproximatelyEqual.html">ndarray::ApproximatelyEqual&lt; T1, T2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary predicate for floating point equality comparison with tolerance.  <a href="structndarray_1_1ApproximatelyEqual.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndarray_1_1ApproximatelyEqual_3_01std_1_1complex_3_01U1_01_4_00_01std_1_1complex_3_01U2_01_4_01_4.html">ndarray::ApproximatelyEqual&lt; std::complex&lt; U1 &gt;, std::complex&lt; U2 &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary predicate for complex floating point equality comparison with tolerance.  <a href="structndarray_1_1ApproximatelyEqual_3_01std_1_1complex_3_01U1_01_4_00_01std_1_1complex_3_01U2_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndarray_1_1ArrayBase.html">ndarray::ArrayBase&lt; Derived &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRTP implementation for <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> and <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a>.  <a href="classndarray_1_1ArrayBase.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndarray_1_1ExpressionBase.html">ndarray::ExpressionBase&lt; Derived &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CRTP base class for all multidimensional expressions.  <a href="classndarray_1_1ExpressionBase.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga4b75bea23c0df8e3d291362ea8008f1c">ndarray::DataOrderEnum</a> { <b>ROW_MAJOR</b> = 1, 
<b>COLUMN_MAJOR</b> = 2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>An enumeration for stride computation standards. </p>
<br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T_ , typename T , int N, int C&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T_, N, C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gab61a786f93ab9b258dd92d747d0e7489">ndarray::const_array_cast</a> (Array&lt; T, N, C &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int C_, typename T , int N, int C&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T, N, C_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gab1b550cc9b5073351728a474d91ff965">ndarray::static_dimension_cast</a> (Array&lt; T, N, C &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int C_, typename T , int N, int C&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T, N, C_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga3e994c309e6606c643d2058518996de4">ndarray::dynamic_dimension_cast</a> (Array&lt; T, N, C &gt; const &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga654e5e1c1fc0a49bdb93ee69950d8767"></a><!-- doxytag: member="MainGroup::getReal" ref="ga654e5e1c1fc0a49bdb93ee69950d8767" args="(Array_ const &amp;array)" -->
template&lt;typename Array_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ComplexExtractor<br class="typebreak"/>
&lt; Array_ &gt;::Result&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga654e5e1c1fc0a49bdb93ee69950d8767">ndarray::getReal</a> (Array_ const &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a> view into the real part of a complex array. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf94eafb9879708584a0c8931371c75cd"></a><!-- doxytag: member="MainGroup::getImag" ref="gaf94eafb9879708584a0c8931371c75cd" args="(Array_ const &amp;array)" -->
template&lt;typename Array_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ComplexExtractor<br class="typebreak"/>
&lt; Array_ &gt;::Result&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gaf94eafb9879708584a0c8931371c75cd">ndarray::getImag</a> (Array_ const &amp;array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a> view into the imaginary part of a complex array. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabfe55b9e300adb13caf94f43b49c2718"></a><!-- doxytag: member="MainGroup::flatten" ref="gabfe55b9e300adb13caf94f43b49c2718" args="(Array&lt; T, N, C &gt; const &amp;input)" -->
template&lt;int Nf, typename T , int N, int C&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">C Nf N::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>ndarray::flatten</b> (Array&lt; T, N, C &gt; const &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::SimpleInitializer&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gafbb7280232bd913033484442f1ebc5ad">ndarray::allocate</a> (Vector&lt; int, N &gt; const &amp;shape)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that allocates uninitialized memory for an array.  <a href="#gafbb7280232bd913033484442f1ebc5ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail::SimpleInitializer&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga789ef37078fc938a0491539217900e4d">ndarray::allocate</a> (int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that allocates uninitialized memory for a 1-d array.  <a href="#ga789ef37078fc938a0491539217900e4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail::SimpleInitializer&lt; 2 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gab084de5d7f9215f147c9dcadf9580385">ndarray::allocate</a> (int n1, int n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that allocates uninitialized memory for a 2-d array.  <a href="#gab084de5d7f9215f147c9dcadf9580385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail::SimpleInitializer&lt; 3 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga85462721b80b50359f11d7c02bc3a355">ndarray::allocate</a> (int n1, int n2, int n3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that allocates uninitialized memory for a 3-d array.  <a href="#ga85462721b80b50359f11d7c02bc3a355"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga825deb5ca8018dd434e135df0dace4da"></a><!-- doxytag: member="MainGroup::copy" ref="ga825deb5ca8018dd434e135df0dace4da" args="(ExpressionBase&lt; Derived &gt; const &amp;expr)" -->
template&lt;typename Derived &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ArrayRef&lt; typename <br class="typebreak"/>
boost::remove_const&lt; typename <br class="typebreak"/>
Derived::Element &gt;::type, <br class="typebreak"/>
Derived::ND::value, <br class="typebreak"/>
Derived::ND::value &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga825deb5ca8018dd434e135df0dace4da">ndarray::copy</a> (ExpressionBase&lt; Derived &gt; const &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> by copying an Expression. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga24fde993ad8805c094e28f513bdd1361"></a><!-- doxytag: member="MainGroup::computeStrides" ref="ga24fde993ad8805c094e28f513bdd1361" args="(Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order=ROW_MAJOR)" -->
template&lt;int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; int, N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga24fde993ad8805c094e28f513bdd1361">ndarray::computeStrides</a> (Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order=ROW_MAJOR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute row- or column-major strides for the given shape. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Owner &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ExternalInitializer&lt; T, <br class="typebreak"/>
N, Owner &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gabde675d7b0a2acae9d48a3250eb50e09">ndarray::external</a> (T *data, Vector&lt; int, N &gt; const &amp;shape, Vector&lt; int, N &gt; const &amp;strides, Owner const &amp;owner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory.  <a href="#gabde675d7b0a2acae9d48a3250eb50e09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ExternalInitializer&lt; T, <br class="typebreak"/>
N, detail::NullOwner &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gaa548d4fc107765d6e33a1733d8b396ee">ndarray::external</a> (T *data, Vector&lt; int, N &gt; const &amp;shape, Vector&lt; int, N &gt; const &amp;strides)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory.  <a href="#gaa548d4fc107765d6e33a1733d8b396ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Owner &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ExternalInitializer&lt; T, <br class="typebreak"/>
N, Owner &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga56a81540b0529198a3b2477104f51be4">ndarray::external</a> (T *data, Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order, Owner const &amp;owner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory.  <a href="#ga56a81540b0529198a3b2477104f51be4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::ExternalInitializer&lt; T, <br class="typebreak"/>
N, detail::NullOwner &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga3c2de173b3d0365b7775f14c1abe7803">ndarray::external</a> (T *data, Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order=ROW_MAJOR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory.  <a href="#ga3c2de173b3d0365b7775f14c1abe7803"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad7e8e8a934cb10dc634c7b7bcd13e69a"></a><!-- doxytag: member="MainGroup::any" ref="gad7e8e8a934cb10dc634c7b7bcd13e69a" args="(ExpressionBase&lt; Derived &gt; const &amp;expr)" -->
template&lt;typename Derived &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gad7e8e8a934cb10dc634c7b7bcd13e69a">ndarray::any</a> (ExpressionBase&lt; Derived &gt; const &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if any of the elements of the given expression are true. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga78562a5090fd39c28e28d8772f5efc47"></a><!-- doxytag: member="MainGroup::all" ref="ga78562a5090fd39c28e28d8772f5efc47" args="(ExpressionBase&lt; Derived &gt; const &amp;expr)" -->
template&lt;typename Derived &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga78562a5090fd39c28e28d8772f5efc47">ndarray::all</a> (ExpressionBase&lt; Derived &gt; const &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all of the elements of the given expression are true. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga003bab238da392e9b4e03ec13a7fbe6e"></a><!-- doxytag: member="MainGroup::sum" ref="ga003bab238da392e9b4e03ec13a7fbe6e" args="(ExpressionBase&lt; Derived &gt; const &amp;expr)" -->
template&lt;typename Derived &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Derived::Element&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga003bab238da392e9b4e03ec13a7fbe6e">ndarray::sum</a> (ExpressionBase&lt; Derived &gt; const &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the sum of all elements of the given expression. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction::result_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#gaecb6d7c11ffe2b04e28fdbe0f5f34a92">ndarray::vectorize</a> (UnaryFunction const &amp;functor, Scalar const &amp;scalar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a non-mutating unary function object to a scalar.  <a href="#gaecb6d7c11ffe2b04e28fdbe0f5f34a92"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::UnaryOpExpression<br class="typebreak"/>
&lt; Derived, UnaryFunction &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga1bee274c443126430eed98d67bed7bed">ndarray::vectorize</a> (UnaryFunction const &amp;functor, ExpressionBase&lt; Derived &gt; const &amp;operand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a non-mutating unary function object to each element of a multidimensional Expression.  <a href="#ga1bee274c443126430eed98d67bed7bed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">BinaryFunction::result_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga79f1a4f3b0c018adba38d35a2b9b0ac1">ndarray::vectorize</a> (BinaryFunction const &amp;functor, Scalar1 const &amp;scalar1, Scalar2 const &amp;scalar2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a non-mutating binary function object to a pair of scalars.  <a href="#ga79f1a4f3b0c018adba38d35a2b9b0ac1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::BinaryOpExpression<br class="typebreak"/>
&lt; Derived1, Derived2, <br class="typebreak"/>
BinaryFunction &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MainGroup.html#ga512cc464b41af19cfc5093588f16fe3f">ndarray::vectorize</a> (BinaryFunction const &amp;functor, ExpressionBase&lt; Derived1 &gt; const &amp;operand1, ExpressionBase&lt; Derived2 &gt; const &amp;operand2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a non-mutating binary function object pairwise to the elements of two multidimensional Expressions.  <a href="#ga512cc464b41af19cfc5093588f16fe3f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39cf8a3daca58c075fe43e6b947533cb"></a><!-- doxytag: member="MainGroup::Nf" ref="ga39cf8a3daca58c075fe43e6b947533cb" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ndarray::Nf</b></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab61a786f93ab9b258dd92d747d0e7489"></a><!-- doxytag: member="ndarray::const_array_cast" ref="gab61a786f93ab9b258dd92d747d0e7489" args="(Array&lt; T, N, C &gt; const &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_ , typename T , int N, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;T_,N,C&gt; ndarray::const_array_cast </td>
          <td>(</td>
          <td class="paramtype">Array&lt; T, N, C &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with a const data type to an array with a non-const data type. </p>

</div>
</div>
<a class="anchor" id="gab1b550cc9b5073351728a474d91ff965"></a><!-- doxytag: member="ndarray::static_dimension_cast" ref="gab1b550cc9b5073351728a474d91ff965" args="(Array&lt; T, N, C &gt; const &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int C_, typename T , int N, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;T,N,C_&gt; ndarray::static_dimension_cast </td>
          <td>(</td>
          <td class="paramtype">Array&lt; T, N, C &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> to a type with more guaranteed row-major-contiguous dimensions with no checking. </p>

</div>
</div>
<a class="anchor" id="ga3e994c309e6606c643d2058518996de4"></a><!-- doxytag: member="ndarray::dynamic_dimension_cast" ref="ga3e994c309e6606c643d2058518996de4" args="(Array&lt; T, N, C &gt; const &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int C_, typename T , int N, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;T,N,C_&gt; ndarray::dynamic_dimension_cast </td>
          <td>(</td>
          <td class="paramtype">Array&lt; T, N, C &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> to a type with more guaranteed row-major-contiguous dimensions, if the strides of the array match the desired number of RMC dimensions. If the cast fails, an empty <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> is returned. </p>

</div>
</div>
<a class="anchor" id="gafbb7280232bd913033484442f1ebc5ad"></a><!-- doxytag: member="ndarray::allocate" ref="gafbb7280232bd913033484442f1ebc5ad" args="(Vector&lt; int, N &gt; const &amp;shape)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::SimpleInitializer&lt;N&gt; ndarray::allocate </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that allocates uninitialized memory for an array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with fully contiguous row-major strides. </dd></dl>

</div>
</div>
<a class="anchor" id="ga789ef37078fc938a0491539217900e4d"></a><!-- doxytag: member="ndarray::allocate" ref="ga789ef37078fc938a0491539217900e4d" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::SimpleInitializer&lt;1&gt; ndarray::allocate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that allocates uninitialized memory for a 1-d array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with fully contiguous row-major strides. </dd></dl>

</div>
</div>
<a class="anchor" id="gab084de5d7f9215f147c9dcadf9580385"></a><!-- doxytag: member="ndarray::allocate" ref="gab084de5d7f9215f147c9dcadf9580385" args="(int n1, int n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::SimpleInitializer&lt;2&gt; ndarray::allocate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that allocates uninitialized memory for a 2-d array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with fully contiguous row-major strides. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85462721b80b50359f11d7c02bc3a355"></a><!-- doxytag: member="ndarray::allocate" ref="ga85462721b80b50359f11d7c02bc3a355" args="(int n1, int n2, int n3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::SimpleInitializer&lt;3&gt; ndarray::allocate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that allocates uninitialized memory for a 3-d array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with fully contiguous row-major strides. </dd></dl>

</div>
</div>
<a class="anchor" id="gabde675d7b0a2acae9d48a3250eb50e09"></a><!-- doxytag: member="ndarray::external" ref="gabde675d7b0a2acae9d48a3250eb50e09" args="(T *data, Vector&lt; int, N &gt; const &amp;shape, Vector&lt; int, N &gt; const &amp;strides, Owner const &amp;owner)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename Owner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ExternalInitializer&lt;T,N,Owner&gt; ndarray::external </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Owner const &amp;&nbsp;</td>
          <td class="paramname"> <em>owner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory. </p>
<p>No checking is done to ensure the shape, strides, and data pointers are sensible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A raw pointer to the first element of the <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of dimensions for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strides</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of strides for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>owner</em>&nbsp;</td><td>A copy-constructable object with an internal reference count that owns the memory pointed at by 'data'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa548d4fc107765d6e33a1733d8b396ee"></a><!-- doxytag: member="ndarray::external" ref="gaa548d4fc107765d6e33a1733d8b396ee" args="(T *data, Vector&lt; int, N &gt; const &amp;shape, Vector&lt; int, N &gt; const &amp;strides)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ExternalInitializer&lt;T,N,detail::NullOwner&gt; ndarray::external </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>strides</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory. </p>
<p>No checking is done to ensure the shape, strides, and data pointers are sensible. Memory will not be managed at all; the user must ensure the data pointer remains valid for the lifetime of the array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A raw pointer to the first element of the <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of dimensions for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strides</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of strides for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56a81540b0529198a3b2477104f51be4"></a><!-- doxytag: member="ndarray::external" ref="ga56a81540b0529198a3b2477104f51be4" args="(T *data, Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order, Owner const &amp;owner)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename Owner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ExternalInitializer&lt;T,N,Owner&gt; ndarray::external </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataOrderEnum&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Owner const &amp;&nbsp;</td>
          <td class="paramname"> <em>owner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory. </p>
<p>No checking is done to ensure the shape and data pointers are sensible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A raw pointer to the first element of the <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of dimensions for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>Whether the strides are row- or column-major. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>owner</em>&nbsp;</td><td>A copy-constructable object with an internal reference count that owns the memory pointed at by 'data'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c2de173b3d0365b7775f14c1abe7803"></a><!-- doxytag: member="ndarray::external" ref="ga3c2de173b3d0365b7775f14c1abe7803" args="(T *data, Vector&lt; int, N &gt; const &amp;shape, DataOrderEnum order=ROW_MAJOR)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ExternalInitializer&lt;T,N,detail::NullOwner&gt; ndarray::external </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; int, N &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataOrderEnum&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>ROW_MAJOR</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an expression that initializes an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> with externally allocated memory. </p>
<p>No checking is done to ensure the shape and data pointers are sensible. Memory will not be managed at all; the user must ensure the data pointer remains valid for the lifetime of the array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A raw pointer to the first element of the <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>A <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> of dimensions for the new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>Whether the strides are row- or column-major.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A temporary object convertible to an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaecb6d7c11ffe2b04e28fdbe0f5f34a92"></a><!-- doxytag: member="ndarray::vectorize" ref="gaecb6d7c11ffe2b04e28fdbe0f5f34a92" args="(UnaryFunction const &amp;functor, Scalar const &amp;scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">UnaryFunction::result_type ndarray::vectorize </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction const &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar const &amp;&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a non-mutating unary function object to a scalar. </p>
<p>This overload exists to allow recursive usage of the Array-argument vectorize functions. </p>

</div>
</div>
<a class="anchor" id="ga1bee274c443126430eed98d67bed7bed"></a><!-- doxytag: member="ndarray::vectorize" ref="ga1bee274c443126430eed98d67bed7bed" args="(UnaryFunction const &amp;functor, ExpressionBase&lt; Derived &gt; const &amp;operand)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::UnaryOpExpression&lt;Derived,UnaryFunction&gt; ndarray::vectorize </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction const &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionBase&lt; Derived &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>operand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a non-mutating unary function object to each element of a multidimensional Expression. </p>
<p>Evaluation is lazy. </p>

</div>
</div>
<a class="anchor" id="ga79f1a4f3b0c018adba38d35a2b9b0ac1"></a><!-- doxytag: member="ndarray::vectorize" ref="ga79f1a4f3b0c018adba38d35a2b9b0ac1" args="(BinaryFunction const &amp;functor, Scalar1 const &amp;scalar1, Scalar2 const &amp;scalar2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 , typename BinaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BinaryFunction::result_type ndarray::vectorize </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction const &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>scalar2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a non-mutating binary function object to a pair of scalars. </p>
<p>This overload exists to allow recursive usage of the Array-argument vectorize functions. </p>

</div>
</div>
<a class="anchor" id="ga512cc464b41af19cfc5093588f16fe3f"></a><!-- doxytag: member="ndarray::vectorize" ref="ga512cc464b41af19cfc5093588f16fe3f" args="(BinaryFunction const &amp;functor, ExpressionBase&lt; Derived1 &gt; const &amp;operand1, ExpressionBase&lt; Derived2 &gt; const &amp;operand2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 , typename BinaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::BinaryOpExpression&lt;Derived1,Derived2,BinaryFunction&gt; ndarray::vectorize </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction const &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionBase&lt; Derived1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>operand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionBase&lt; Derived2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>operand2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a non-mutating binary function object pairwise to the elements of two multidimensional Expressions. </p>
<p>Evaluation is lazy. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Aug 25 17:30:14 2011 for ndarray by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
